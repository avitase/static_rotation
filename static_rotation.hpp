#include <array>
#include <utility>

namespace static_rotation {
namespace detail {

/**
 * @class Rotator
 * @brief Rotates a given integral sequence N times.
 *
 * The Rotator class generates N-1 rotations of a given integral sequence.
 * Rotations are generated by consecutively left-rotating the last sequence,
 * e.g. rotating the sequence (0, 1, 2, 3) two times (N=3) results in the three sequences:
 *
 * (0, 1, 2, 3),
 * (1, 2, 3, 0) and
 * (2, 3, 0, 1).
 *
 * @tparam N number of consecutive rotations (as std::integral_constant with value_type std::size_t)
 * @tparam T value type of the integral sequence
 * @tparam head first element of integral sequence
 * @tparam tail tail of integral sequence
 */
template <typename N, typename T, T head, T... tail>
class Rotator {
    static_assert(std::is_same_v<typename N::value_type, std::size_t>);

  private:
    template <T... a, T... b>
    [[nodiscard]] constexpr static auto join(std::integer_sequence<T, a...>,
                                             std::integer_sequence<T, b...>) noexcept {
        return std::integer_sequence<T, a..., b...>{};
    }

    template <T... values>
    [[nodiscard]] constexpr static auto to_array(std::integer_sequence<T, values...>) noexcept {
        return std::array{values...};
    }

  public:
    using next
        = Rotator<std::integral_constant<typename N::value_type, N::value - 1>, T, tail..., head>;

    /**
     * Sequence as parameter pack
     */
    constexpr static auto seq = join(std::integer_sequence<T, head, tail...>{}, next::seq);

    /**
     * Length of the sequence.
     */
    constexpr static auto seq_length = sizeof...(tail) + 1;

    /**
     * All Sequences, consecutively stored in a std::array, e.g.:
     * (0, 1, 2, 1, 2, 0, 2, 0, 1) for the (underlying) sequence (0, 1, 2).
     */
    constexpr static auto values = to_array(seq);
};

/**
 * @class Rotator
 * @brief Specialization of Rotator for N = 0
 *
 * @tparam T value type of the integral sequence
 * @tparam head first element of integral sequence
 * @tparam tail tail of integral sequence
 */
template <typename T, T head, T... tail>
struct Rotator<std::integral_constant<std::size_t, 0>, T, head, tail...> {
    constexpr static auto seq = std::integer_sequence<T>{};
};
} // namespace detail

/**
 * @class Rotations
 * @brief Generates all rotations of a given integral sequence.
 *
 * The Rotations class generates all rotations of a given integral sequence.
 * Rotations are generated by consecutively left-rotating the last sequence,
 * e.g. rotating the sequence (0, 1, 2, 3) results in the four sequences:
 *
 * (0, 1, 2, 3),
 * (1, 2, 3, 0),
 * (2, 3, 0, 1) and
 * (3, 0, 1, 2).
 *
 * @tparam T value type of the integral sequence
 * @tparam values integral sequence
 * @sa details::Rotator
 */
template <typename T, T... values>
using Rotations
    = detail::Rotator<std::integral_constant<std::size_t, sizeof...(values)>, T, values...>;

namespace detail {
template <std::size_t... idxs>
[[nodiscard]] constexpr auto
make_index_rotations(std::integer_sequence<std::size_t, idxs...>) noexcept {
    return Rotations<std::size_t, idxs...>{};
}
} // namespace detail

/**
 * @class IndexRotations
 * @brief Generates all rotations of an ascending integer sequence.
 *
 * The IndexRotations class generates all rotations of an ascending integers sequence of type
 * std::size_t. The integer sequence starts with zero and ends with N-1, e.g. (0, 1, 2, 3, 4)
 * for N = 5. IndexRotations is an alias of the Rotations class.
 *
 * @tparam N upper bound for generated sequence
 * @sa Rotations
 */
template <std::size_t N>
using IndexRotations = decltype(detail::make_index_rotations(std::make_index_sequence<N>{}));
} // namespace static_rotation
